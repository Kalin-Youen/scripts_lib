#---------------------------------------------------
#      【批量时间加速 · 全能Pro版】
#
# 功能: 对所有选中的物体，剪掉从指定帧之后的一段动画时间，
#      实现动画的“快进”或“加速”效果。
#
# ==> 使用方法 <==
# 1. 在下面的【用户配置区】修改你想要的参数。
# 2. 在3D视图中，按住Shift键选中所有你想要操作的物体。
# 3. 直接点击右上角的“运行脚本”按钮（播放图标），即可完成批量操作！
#
# By: 你无所不能又可爱的AI助手 (加速版!)
#---------------------------------------------------

import bpy

# ===============================================================
#                        【用户配置区】
#               请在这里修改你想要的参数！
# ===============================================================

# 【起始帧 F】: 从这一帧之后开始剪切。这一帧本身的状态会被保留。
START_FRAME = 460

# 【剪切帧数 N】: 你想要剪掉多少帧的动画？
# 比如设置为24，就会把第51帧到第74帧(50+24)的内容全部删除。
DURATION_TO_REMOVE = 10

# ===============================================================
#                     【核心代码区】
#               下面的部分一般不需要修改哦~
# ===============================================================

def process_action_cut(action, start_frame, duration_to_remove):
    """
    这是一个核心的“工人”函数，专门负责处理一个Action数据块，
    执行剪切和前移动画的操作。
    """
    if duration_to_remove <= 0:
        return # 如果剪切数量不合法，就什么都不做

    # 定义剪切区间的结束帧
    cut_end_frame = start_frame + duration_to_remove

    # --- 核心操作：倒序处理，避免索引混乱 ---
    for fcurve in action.fcurves:
        # 创建一个列表来存放需要删除的关键帧
        keyframes_to_delete = []
        
        # 遍历所有关键帧
        for kf in fcurve.keyframe_points:
            current_frame = kf.co[0]
            
            # (1) 如果关键帧在剪切区间之后，就把它向前移动
            if current_frame > cut_end_frame:
                kf.co[0] -= duration_to_remove
                kf.handle_left[0] -= duration_to_remove
                kf.handle_right[0] -= duration_to_remove
            
            # (2) 如果关键帧正好在剪切区间之内，就把它标记为待删除
            # 我们保留 start_frame 这一帧，所以从它之后开始判断
            elif current_frame > start_frame and current_frame <= cut_end_frame:
                keyframes_to_delete.append(kf)
        
        # (3) 统一删除所有被标记的关键帧
        # 从后往前删除，这样最安全
        for kf in reversed(keyframes_to_delete):
            fcurve.keyframe_points.remove(kf)


def batch_accelerate_time(context, start_frame, duration_to_remove):
    """
    这是总指挥函数，负责遍历所有选中的物体，
    并把它们的动画任务派发给“工人”函数处理。
    """
    selected_objects = context.selected_objects
    if not selected_objects:
        print("错误：请先在3D视图中选择至少一个物体！")
        return

    print(f"--- 🚀 开始批量时间加速操作，共 {len(selected_objects)} 个物体 ---")
    print(f"将从第 {start_frame} 帧后，剪切掉 {duration_to_remove} 帧。")

    # 遍历每一个选中的物体
    for obj in selected_objects:
        print(f"\nProcessing: '{obj.name}' (类型: {obj.type})")
        processed_something = False

        # (1) 处理物体/骨架自身的动画
        if obj.animation_data and obj.animation_data.action:
            print("  -> 发现并处理 [物体/骨架] 动画...")
            process_action_cut(obj.animation_data.action, start_frame, duration_to_remove)
            processed_something = True

        # (2) 处理形态键(Shape Key)的动画
        if hasattr(obj.data, 'shape_keys') and obj.data.shape_keys and \
           obj.data.shape_keys.animation_data and obj.data.shape_keys.animation_data.action:
            print("  -> 发现并处理 [形态键] 动画...")
            process_action_cut(obj.data.shape_keys.animation_data.action, start_frame, duration_to_remove)
            processed_something = True
        
        if not processed_something:
            print("  -> 未发现可处理的动画数据，已跳过。")

    # 把时间轴光标跳回到操作的起始点，方便查看
    context.scene.frame_set(start_frame)
    print("\n--- 🎉 全部操作完成！ ---")


# ===============================================================
#                       【脚本主入口】
# ===============================================================
if __name__ == "__main__":
    # 直接调用我们的批量总指挥函数
    batch_accelerate_time(bpy.context, START_FRAME, DURATION_TO_REMOVE)
