import bpy

class OBJECT_OT_batch_create_time_pause(bpy.types.Operator):
    """åœ¨æŒ‡å®šå¸§åä¸ºé€‰ä¸­ç‰©ä½“æ’å…¥é™æ­¢æ—¶é—´ï¼Œä½¿ç”¨è´å¡å°”å…³é”®å¸§é¿å…çº¢è‰²Constantå¸§"""
    bl_idname = "object.batch_create_time_pause"
    bl_label = "æ‰¹é‡åˆ›å»ºæ—¶é—´åœé¡¿ï¼ˆè´å¡å°”ç‰ˆï¼‰"
    bl_options = {'REGISTER', 'UNDO'}

    # å¯ç¼–è¾‘å±æ€§ï¼ˆä¼šæ˜¾ç¤ºåœ¨å¼¹çª—ä¸­ï¼‰
    start_frame: bpy.props.IntProperty(
        name="èµ·å§‹å¸§",
        description="ä»å“ªä¸€å¸§å¼€å§‹æ’å…¥åœé¡¿",
        default=1,
        min=0
    )

    insert_duration: bpy.props.IntProperty(
        name="æ’å…¥å¸§æ•°",
        description="è¦æ’å…¥å¤šå°‘å¸§çš„é™æ­¢æ—¶é—´",
        default=20,
        min=1
    )

    def invoke(self, context, event):
        """è°ƒç”¨æ—¶å¼¹å‡ºè®¾ç½®çª—å£"""
        self.start_frame = context.scene.frame_current  # é»˜è®¤ä¸ºå½“å‰å¸§
        return context.window_manager.invoke_props_dialog(self)

    def draw(self, context):
        """ç»˜åˆ¶å¼¹çª—ç•Œé¢"""
        layout = self.layout
        layout.label(text="è®¾ç½®åœé¡¿å‚æ•°ï¼š", icon='PREFERENCES')
        layout.prop(self, "start_frame")
        layout.prop(self, "insert_duration")
        layout.separator()
        layout.label(text="æç¤ºï¼šä½¿ç”¨è´å¡å°”å…³é”®å¸§å®ç°åœé¡¿ï¼Œæ— çº¢è‰²å¸§", icon='INFO')

    @staticmethod
    def process_action_pause(action, start_frame, insert_duration):
        """
        æ ¸å¿ƒå¤„ç†ï¼šç§»åŠ¨å…³é”®å¸§ + æ’å…¥ä¸¤ä¸ªè´å¡å°”å…³é”®å¸§å®ç°â€œåœé¡¿â€
        """
        if not action or insert_duration <= 0:
            return

        # 1. ç§»åŠ¨æ‰€æœ‰åœ¨èµ·å§‹å¸§ä¹‹åçš„å…³é”®å¸§
        for fcurve in action.fcurves:
            for kf in reversed(fcurve.keyframe_points):
                if kf.co[0] > start_frame:
                    kf.co[0] += insert_duration
                    try:
                        kf.handle_left[0] += insert_duration
                        kf.handle_right[0] += insert_duration
                    except (AttributeError, TypeError):
                        pass  # å¿½ç•¥æ— æ•ˆæ‰‹æŸ„

        # 2. ä¸ºæ¯ä¸ªF-Curveæ’å…¥åœé¡¿åŒºé—´
        for fcurve in action.fcurves:
            if not fcurve.keyframe_points:
                continue

            # è·å–èµ·å§‹å¸§çš„å€¼
            value_at_start = fcurve.evaluate(start_frame)
            end_frame = start_frame + insert_duration

            # æ’å…¥èµ·å§‹å¸§ï¼ˆè´å¡å°” + VECTORæ‰‹æŸ„ï¼‰
            try:
                kf_start = fcurve.keyframe_points.insert(frame=start_frame, value=value_at_start)
                kf_start.interpolation = 'BEZIER'
                kf_start.handle_left_type = 'VECTOR'
                kf_start.handle_right_type = 'VECTOR'
            except RuntimeError:
                pass  # å¿½ç•¥å·²å­˜åœ¨å…³é”®å¸§çš„æ’å…¥é”™è¯¯

            # æ’å…¥ç»“æŸå¸§ï¼ˆç›¸åŒå€¼ï¼‰
            try:
                kf_end = fcurve.keyframe_points.insert(frame=end_frame, value=value_at_start)
                kf_end.interpolation = 'BEZIER'
                kf_end.handle_left_type = 'VECTOR'
                kf_end.handle_right_type = 'VECTOR'
            except RuntimeError:
                pass

    def execute(self, context):
        selected_objects = context.selected_objects
        if not selected_objects:
            self.report({'WARNING'}, "âš ï¸ æœªé€‰æ‹©ä»»ä½•ç‰©ä½“ï¼")
            # å»¶è¿Ÿæ³¨é”€
            bpy.app.timers.register(lambda: self.unregister_timer(), first_interval=0.1)
            return {'CANCELLED'}

        start_frame = self.start_frame
        insert_duration = self.insert_duration

        self.report({'INFO'}, f"â–¶ï¸ å¼€å§‹æ‰¹é‡æ—¶é—´åœé¡¿: èµ·å§‹å¸§={start_frame}, æŒç»­={insert_duration}å¸§")

        processed_count = 0
        for obj in selected_objects:
            # å¤„ç†ç‰©ä½“åŠ¨ç”»
            if obj.animation_data and obj.animation_data.action:
                self.process_action_pause(obj.animation_data.action, start_frame, insert_duration)
                processed_count += 1

            # å¤„ç†å½¢å˜é”®åŠ¨ç”»ï¼ˆShape Keysï¼‰
            if (hasattr(obj.data, 'shape_keys') and 
                obj.data.shape_keys and 
                obj.data.shape_keys.animation_data and 
                obj.data.shape_keys.animation_data.action):
                self.process_action_pause(obj.data.shape_keys.animation_data.action, start_frame, insert_duration)
                processed_count += 1

        # è·³è½¬åˆ°åœé¡¿ç»“æŸä½ç½®
        context.scene.frame_set(start_frame + insert_duration)

        self.report({'INFO'}, f"âœ… æ‰¹é‡æ—¶é—´åœé¡¿å®Œæˆï¼å…±å¤„ç† {processed_count} ä¸ªåŠ¨ç”»æ•°æ®ã€‚")
        
        # å»¶è¿Ÿæ³¨é”€æ“ä½œç¬¦
        bpy.app.timers.register(lambda: self.unregister_timer(), first_interval=0.1)
        return {'FINISHED'}

    def unregister_timer(self):
        """å®‰å…¨æ³¨é”€æ“ä½œç¬¦ç±»"""
        try:
            bpy.utils.unregister_class(OBJECT_OT_batch_create_time_pause)
            print(f"ğŸ—‘ï¸ æ“ä½œç¬¦ {self.bl_idname} å·²æ³¨é”€ã€‚")
        except (RuntimeError, AttributeError):
            pass


# ========================
#  æ³¨å†Œä¸è¿è¡Œå‡½æ•°
# ========================

def register_and_run():
    """æ³¨å†Œç±»å¹¶è°ƒç”¨æ“ä½œç¬¦ï¼ˆå¼¹å‡ºçª—å£ï¼‰"""
    # å…ˆå°è¯•æ³¨é”€æ—§ç‰ˆæœ¬ï¼ˆé¿å…é‡å¤æ³¨å†Œé”™è¯¯ï¼‰
    try:
        bpy.utils.unregister_class(OBJECT_OT_batch_create_time_pause)
    except (RuntimeError, AttributeError):
        pass

    # æ³¨å†Œå¹¶è°ƒç”¨
    bpy.utils.register_class(OBJECT_OT_batch_create_time_pause)
    bpy.ops.object.batch_create_time_pause('INVOKE_DEFAULT')


# ========================
#  è„šæœ¬ä¸»å…¥å£
# ========================

if __name__ == "__main__":
    register_and_run()