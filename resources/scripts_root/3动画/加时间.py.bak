import bpy

class OBJECT_OT_batch_create_time_pause(bpy.types.Operator):
    """在指定帧后为选中物体插入静止时间，使用贝塞尔关键帧避免红色Constant帧"""
    bl_idname = "object.batch_create_time_pause"
    bl_label = "批量创建时间停顿（贝塞尔版）"
    bl_options = {'REGISTER', 'UNDO'}

    # 可编辑属性（会显示在弹窗中）
    start_frame: bpy.props.IntProperty(
        name="起始帧",
        description="从哪一帧开始插入停顿",
        default=1,
        min=0
    )

    insert_duration: bpy.props.IntProperty(
        name="插入帧数",
        description="要插入多少帧的静止时间",
        default=20,
        min=1
    )

    def invoke(self, context, event):
        """调用时弹出设置窗口"""
        self.start_frame = context.scene.frame_current  # 默认为当前帧
        return context.window_manager.invoke_props_dialog(self)

    def draw(self, context):
        """绘制弹窗界面"""
        layout = self.layout
        layout.label(text="设置停顿参数：", icon='PREFERENCES')
        layout.prop(self, "start_frame")
        layout.prop(self, "insert_duration")
        layout.separator()
        layout.label(text="提示：使用贝塞尔关键帧实现停顿，无红色帧", icon='INFO')

    @staticmethod
    def process_action_pause(action, start_frame, insert_duration):
        """
        核心处理：移动关键帧 + 插入两个贝塞尔关键帧实现“停顿”
        """
        if not action or insert_duration <= 0:
            return

        # 1. 移动所有在起始帧之后的关键帧
        for fcurve in action.fcurves:
            for kf in reversed(fcurve.keyframe_points):
                if kf.co[0] > start_frame:
                    kf.co[0] += insert_duration
                    try:
                        kf.handle_left[0] += insert_duration
                        kf.handle_right[0] += insert_duration
                    except (AttributeError, TypeError):
                        pass  # 忽略无效手柄

        # 2. 为每个F-Curve插入停顿区间
        for fcurve in action.fcurves:
            if not fcurve.keyframe_points:
                continue

            # 获取起始帧的值
            value_at_start = fcurve.evaluate(start_frame)
            end_frame = start_frame + insert_duration

            # 插入起始帧（贝塞尔 + VECTOR手柄）
            try:
                kf_start = fcurve.keyframe_points.insert(frame=start_frame, value=value_at_start)
                kf_start.interpolation = 'BEZIER'
                kf_start.handle_left_type = 'VECTOR'
                kf_start.handle_right_type = 'VECTOR'
            except RuntimeError:
                pass  # 忽略已存在关键帧的插入错误

            # 插入结束帧（相同值）
            try:
                kf_end = fcurve.keyframe_points.insert(frame=end_frame, value=value_at_start)
                kf_end.interpolation = 'BEZIER'
                kf_end.handle_left_type = 'VECTOR'
                kf_end.handle_right_type = 'VECTOR'
            except RuntimeError:
                pass

    def execute(self, context):
        selected_objects = context.selected_objects
        if not selected_objects:
            self.report({'WARNING'}, "⚠️ 未选择任何物体！")
            # 延迟注销
            bpy.app.timers.register(lambda: self.unregister_timer(), first_interval=0.1)
            return {'CANCELLED'}

        start_frame = self.start_frame
        insert_duration = self.insert_duration

        self.report({'INFO'}, f"▶️ 开始批量时间停顿: 起始帧={start_frame}, 持续={insert_duration}帧")

        processed_count = 0
        for obj in selected_objects:
            # 处理物体动画
            if obj.animation_data and obj.animation_data.action:
                self.process_action_pause(obj.animation_data.action, start_frame, insert_duration)
                processed_count += 1

            # 处理形变键动画（Shape Keys）
            if (hasattr(obj.data, 'shape_keys') and 
                obj.data.shape_keys and 
                obj.data.shape_keys.animation_data and 
                obj.data.shape_keys.animation_data.action):
                self.process_action_pause(obj.data.shape_keys.animation_data.action, start_frame, insert_duration)
                processed_count += 1

        # 跳转到停顿结束位置
        context.scene.frame_set(start_frame + insert_duration)

        self.report({'INFO'}, f"✅ 批量时间停顿完成！共处理 {processed_count} 个动画数据。")
        
        # 延迟注销操作符
        bpy.app.timers.register(lambda: self.unregister_timer(), first_interval=0.1)
        return {'FINISHED'}

    def unregister_timer(self):
        """安全注销操作符类"""
        try:
            bpy.utils.unregister_class(OBJECT_OT_batch_create_time_pause)
            print(f"🗑️ 操作符 {self.bl_idname} 已注销。")
        except (RuntimeError, AttributeError):
            pass


# ========================
#  注册与运行函数
# ========================

def register_and_run():
    """注册类并调用操作符（弹出窗口）"""
    # 先尝试注销旧版本（避免重复注册错误）
    try:
        bpy.utils.unregister_class(OBJECT_OT_batch_create_time_pause)
    except (RuntimeError, AttributeError):
        pass

    # 注册并调用
    bpy.utils.register_class(OBJECT_OT_batch_create_time_pause)
    bpy.ops.object.batch_create_time_pause('INVOKE_DEFAULT')


# ========================
#  脚本主入口
# ========================

if __name__ == "__main__":
    register_and_run()