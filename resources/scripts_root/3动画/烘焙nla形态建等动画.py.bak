import bpy

def cleanup_action_smarter(action, threshold=0.001):
    """
    ä¸€ä¸ªæ›´æ™ºèƒ½çš„æ¸…ç†å‡½æ•°ï¼Œä½¿ç”¨é˜ˆå€¼æ¥ç§»é™¤å‡ ä¹ä¸å˜çš„å†—ä½™å…³é”®å¸§ã€‚
    å®ƒèƒ½æ›´å¥½åœ°ä¿ç•™åŠ¨ç”»çš„èŠ‚å¥å’Œâ€œä¿æŒâ€å§¿åŠ¿ã€‚
    """
    if not action or not action.fcurves:
        return

    print(f"    - å¯åŠ¨æ™ºèƒ½æ¸…ç†ï¼ŒåŠ¨ä½œ: '{action.name}', å®¹å·®: {threshold}")
    total_removed = 0

    for fcurve in action.fcurves:
        keyframe_points = fcurve.keyframe_points
        if len(keyframe_points) < 3:
            continue

        # åˆ›å»ºä¸€ä¸ªè¦åˆ é™¤çš„å…³é”®å¸§ç´¢å¼•åˆ—è¡¨
        indices_to_remove = []
        
        # æˆ‘ä»¬éœ€è¦ä¸€ä¸ªåŠ¨æ€çš„â€œå‰ä¸€ä¸ªâ€å…³é”®å¸§ï¼Œä»¥å¤„ç†è¿ç»­åˆ é™¤çš„æƒ…å†µ
        prev_kf = keyframe_points[0]

        # ä»ç¬¬äºŒä¸ªç‚¹å¼€å§‹ï¼Œåˆ°å€’æ•°ç¬¬äºŒä¸ªç‚¹ç»“æŸ
        for i in range(1, len(keyframe_points) - 1):
            current_kf = keyframe_points[i]
            next_kf = keyframe_points[i + 1]

            # ---------------- æ™ºèƒ½åˆ¤æ–­é€»è¾‘ ----------------
            # ä½¿ç”¨çº¿æ€§æ’å€¼ï¼ˆlerpï¼‰æ¥é¢„æµ‹å½“å‰å¸§çš„å€¼åº”è¯¥æ˜¯ä»€ä¹ˆ
            # t æ˜¯å½“å‰å¸§åœ¨å‰åä¸¤ä¸ªå…³é”®å¸§ä¹‹é—´çš„æ—¶é—´æ¯”ä¾‹
            time_diff = next_kf.co.x - prev_kf.co.x
            if time_diff == 0: continue # é¿å…é™¤ä»¥é›¶
            
            t = (current_kf.co.x - prev_kf.co.x) / time_diff
            
            # æ ¹æ®å‰åä¸¤ä¸ªç‚¹çš„å€¼ï¼Œé¢„æµ‹ä¸­é—´ç‚¹çš„å€¼
            predicted_value = prev_kf.co.y + t * (next_kf.co.y - prev_kf.co.y)
            
            # å¦‚æœå®é™…å€¼ä¸é¢„æµ‹å€¼çš„å·®å¼‚åœ¨é˜ˆå€¼ä¹‹å†…ï¼Œåˆ™è®¤ä¸ºæ˜¯å†—ä½™çš„
            if abs(current_kf.co.y - predicted_value) < threshold:
                indices_to_remove.append(i)
            else:
                # å¦‚æœè¿™ä¸ªç‚¹ä¸æ˜¯å†—ä½™çš„ï¼Œå®ƒå°±æˆä¸ºä¸‹ä¸€æ¬¡æ¯”è¾ƒçš„â€œå‰ä¸€ä¸ªâ€ç‚¹
                prev_kf = current_kf
        
        # ä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•é”™ä¹±
        if indices_to_remove:
            for index in sorted(indices_to_remove, reverse=True):
                keyframe_points.remove(keyframe_points[index])
            total_removed += len(indices_to_remove)

    print(f"    - âœ… æ™ºèƒ½æ¸…ç†å®Œæˆã€‚ç§»é™¤äº† {total_removed} ä¸ªå†—ä½™å…³é”®å¸§ã€‚")


def bake_shape_keys_perfectly(obj, start_frame, end_frame):
    # (æ­¤å‡½æ•°ä¿æŒä¸å˜ï¼Œä½†ä¼šè°ƒç”¨æ–°çš„æ¸…ç†å‡½æ•°)
    print("    - å¯åŠ¨å®Œç¾å½¢æ€é”®çƒ˜ç„™æ¨¡å¼...")
    shape_keys = obj.data.shape_keys
    if not shape_keys or not shape_keys.animation_data:
        print("    - æœªå‘ç°å½¢æ€é”®åŠ¨ç”»æ•°æ®ã€‚")
        return

    new_name = f"{obj.name}_shapekey_baked"
    if new_name in bpy.data.actions:
        bpy.data.actions.remove(bpy.data.actions[new_name])
    new_action = bpy.data.actions.new(name=new_name)

    key_blocks_to_bake = [kb for kb in shape_keys.key_blocks if kb != shape_keys.key_blocks[0]]
    if not key_blocks_to_bake: return

    original_frame = bpy.context.scene.frame_current
    try:
        for frame in range(start_frame, end_frame + 1):
            bpy.context.scene.frame_set(frame)
            bpy.context.view_layer.update() 
            for kb in key_blocks_to_bake:
                data_path = f'key_blocks["{kb.name}"].value'
                fcurve = new_action.fcurves.find(data_path) or new_action.fcurves.new(data_path)
                fcurve.keyframe_points.insert(frame, kb.value)
    finally:
        bpy.context.scene.frame_set(original_frame)

    # è°ƒç”¨æ–°çš„æ™ºèƒ½æ¸…ç†å‡½æ•°ï¼
    cleanup_action_smarter(new_action, threshold=0.001)
            
    shape_keys.animation_data.action = None
    for track in shape_keys.animation_data.nla_tracks: track.mute = True
    shape_keys.animation_data.action = new_action
            
    print(f"    - âœ… å½¢æ€é”®å·²å®Œç¾çƒ˜ç„™å¹¶æ™ºèƒ½æ¸…ç†åˆ°åŠ¨ä½œ: '{new_action.name}'")


def get_total_animation_range(obj):
    # (æ­¤å‡½æ•°ä¿æŒä¸å˜)
    min_frame, max_frame = float('inf'), float('-inf')
    has_anim = False
    
    # ç‰©ä½“/å§¿æ€åŠ¨ç”»
    if obj.animation_data:
        ad = obj.animation_data
        if ad.action:
            min_frame = min(min_frame, ad.action.frame_range[0])
            max_frame = max(max_frame, ad.action.frame_range[1])
            has_anim = True
        for track in ad.nla_tracks:
            if not track.mute and track.strips:
                has_anim = True
                for strip in track.strips:
                    min_frame = min(min_frame, strip.frame_start)
                    max_frame = max(max_frame, strip.frame_end)

    # å½¢æ€é”®åŠ¨ç”»
    if obj.data and hasattr(obj.data, 'shape_keys') and obj.data.shape_keys and obj.data.shape_keys.animation_data:
        sk_ad = obj.data.shape_keys.animation_data
        if sk_ad.action:
            min_frame = min(min_frame, sk_ad.action.frame_range[0])
            max_frame = max(max_frame, sk_ad.action.frame_range[1])
            has_anim = True
        for track in sk_ad.nla_tracks:
            if not track.mute and track.strips:
                has_anim = True
                for strip in track.strips:
                    min_frame = min(min_frame, strip.frame_start)
                    max_frame = max(max_frame, strip.frame_end)
                    
    if not has_anim: return None
    return int(min_frame), int(max_frame)


def bake_and_clean_all_animations_final():
    """
    æœ€ç»ˆç‰ˆä¸»å‡½æ•°ï¼šä½¿ç”¨æ™ºèƒ½æ¸…ç†
    """
    selected_objects = bpy.context.selected_objects
    if not selected_objects:
        print("âŒ è¯·å…ˆé€‰æ‹©ç‰©ä½“ã€‚")
        return {'CANCELLED'}

    original_active_object = bpy.context.view_layer.objects.active
    
    for obj in selected_objects:
        print(f"--- æ­£åœ¨å¤„ç†ç‰©ä½“: {obj.name} ---")
        anim_range = get_total_animation_range(obj)
        if not anim_range:
            print(f"âš ï¸ ç‰©ä½“ '{obj.name}' æœªæ‰¾åˆ°æœ‰æ•ˆåŠ¨ç”»å¸§ï¼Œå·²è·³è¿‡ã€‚")
            continue
        
        start_frame, end_frame = anim_range
        print(f"    - æ€»åŠ¨ç”»èŒƒå›´: {start_frame} åˆ° {end_frame}")

        bpy.ops.object.select_all(action='DESELECT')
        obj.select_set(True)
        bpy.context.view_layer.objects.active = obj
        
        # 1. å¤„ç†ç‰©ä½“å˜æ¢å’Œéª¨æ¶å§¿æ€åŠ¨ç”»
        bake_types = set()
        if obj.type == 'ARMATURE': bake_types.add('POSE')
        if obj.animation_data and (obj.animation_data.action or any(t.strips for t in obj.animation_data.nla_tracks if not t.mute)):
            bake_types.add('OBJECT')
        
        if bake_types:
            print("    - æ­£åœ¨çƒ˜ç„™ç‰©ä½“/å§¿æ€åŠ¨ç”»...")
            original_scene_start, original_scene_end = bpy.context.scene.frame_start, bpy.context.scene.frame_end
            try:
                bpy.context.scene.frame_start, bpy.context.scene.frame_end = start_frame, end_frame
                bpy.ops.nla.bake(
                    only_selected=True, visual_keying=True,
                    use_current_action=True, bake_types=bake_types
                )
            finally:
                bpy.context.scene.frame_start, bpy.context.scene.frame_end = original_scene_start, original_scene_end
            
            if obj.animation_data.action:
                new_action = obj.animation_data.action
                new_action.name = f"{obj.name}_obj_pose_baked"
                # è°ƒç”¨æ–°çš„æ™ºèƒ½æ¸…ç†å‡½æ•°ï¼
                cleanup_action_smarter(new_action, threshold=0.001)
                print(f"    - âœ… ç‰©ä½“/å§¿æ€å·²çƒ˜ç„™å¹¶æ™ºèƒ½æ¸…ç†åˆ°åŠ¨ä½œ: '{new_action.name}'")

        # 2. ç‹¬ç«‹å¤„ç†å½¢æ€é”®åŠ¨ç”»
        if obj.data and hasattr(obj.data, 'shape_keys') and obj.data.shape_keys:
            bake_shape_keys_perfectly(obj, start_frame, end_frame)

    # æ¢å¤åŸå§‹é€‰æ‹©
    bpy.ops.object.select_all(action='DESELECT')
    for obj in selected_objects: obj.select_set(True)
    if original_active_object and original_active_object.name in bpy.context.scene.objects:
        bpy.context.view_layer.objects.active = original_active_object
    
    print("\nğŸ‰ æ‰€æœ‰åŠ¨ç”»å¤„ç†å®Œæˆï¼")
    return {'FINISHED'}


if __name__ == "__main__":
    bake_and_clean_all_animations_final()

