import bpy

def select_top_parent_and_children():
    """
    选择选中物体的最顶层父级及其所有在当前视图层中可见的子级物体。
    如同一位老祖，点名自己家族在场的所有后辈。
    """
    # 确认当前有神念锁定的目标
    if not bpy.context.selected_objects:
        print("神念空悬，未曾锁定任何物体。")
        return

    # 获取当前所在的“界”（View Layer），这是我们神通能及的范围
    view_layer = bpy.context.view_layer
    # 从“生死簿”中获取本“界”所有物体的名录，以备快速查验
    objects_in_view_layer = set(view_layer.objects)
    
    # 准备一个集合，记录已经处理过的顶层老祖，免得重复施法
    processed_parents = set()

    # 遍历所有选中的物体，即便选中了多个不同家族的后辈
    # 我们要为每一个后辈找到他们的顶层老祖
    # 注意：这里要用list()包裹一下，因为在循环中修改选中状态是不安全的
    for obj in list(bpy.context.selected_objects):
        
        # 追本溯源，寻找其最顶层的父级，即为“老祖”
        top_parent = obj
        while top_parent.parent:
            top_parent = top_parent.parent
            
        # 如果这位老祖我们已经拜见过，就不用再重复了
        if top_parent in processed_parents:
            continue
            
        processed_parents.add(top_parent)

        # 确认老祖本人是否在此界，若在，则将其选中
        if top_parent in objects_in_view_layer:
            top_parent.select_set(True)
            print(f"已选中顶层父级: {top_parent.name}")
        else:
            print(f"顶层父级 '{top_parent.name}' 不在此界，已跳过。")


        # 现在，开始点名这位老祖座下的所有后裔
        processed_count = 0
        skipped_count = 0
        
        # 遍历生死簿上所有血脉后裔
        for child in top_parent.children_recursive:
            # --- 核心改动在此 ---
            # 先洞察，再出手！确认这个后裔是否在你当前这个“界”里
            if child in objects_in_view_layer:
                # 若在，则施展“号令”神通，将其选中
                child.select_set(True)
                processed_count += 1
            else:
                # 若不在，则记下，不强求，这才是宗师风范
                skipped_count += 1
        
        print(f"对 '{top_parent.name}' 家族的操作完成: 选中 {processed_count} 个子级, 跳过 {skipped_count} 个不在当前视图层的子级。")

# --- 运行此神通 ---
select_top_parent_and_children()
